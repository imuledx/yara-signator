package main;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import org.apache.commons.codec.DecoderException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import controller.Controller;
import converters.ngrams.Ngram;
import smtx_handler.Instruction;
import yara.Rule;
import yara.RuleCondition;
import yara.RuleMeta;
import yara.RuleStrings;
import yara.YaraRule;
import yara_generation.NgramCreator;

public class YaraRuleGenerator implements Runnable {

	private static final Logger logger = LoggerFactory.getLogger(YaraRuleGenerator.class);
	
	private String family;
	private int family_id;
	private Config config;
	private DateTimeFormatter dtf;
	private LocalDateTime now;
	private int counter;
	private int familiesSize;
	private String condition;
	private List<Ngram> ngrams;
	private String output_folder;
	
	private String disclaimer =   "    /* DISCLAIMER\n"
			+ "     * The strings used in this rule have been automatically selected from the\n"
			+ "     * disassembly of memory dumps and unpacked files, using YARA-Signator.\n"
			+ "     * The code and documentation is published here:\n"
			+ "     * https://github.com/fxb-cocacoding/yara-signator\n"
			+ "     * As Malpedia is used as data source, please note that for a given\n"
			+ "     * number of families, only single samples are documented.\n"
			+ "     * This likely impacts the degree of generalization these rules will offer.\n"
			+ "     * Take the described generation method also into consideration when you\n"
			+ "     * apply the rules in your use cases and assign them confidence levels.\n"
			+ "     */\n\n";


	public YaraRuleGenerator(String family, int family_id, Config config, String output_folder, final DateTimeFormatter dtf,
			LocalDateTime now, int counter, int familiesSize, String condition, List<Ngram> ngrams) {
		this.family = family;
		this.family_id = family_id;
		this.config = config;
		this.dtf = dtf;
		this.now = now;
		this.counter = counter;
		this.output_folder = output_folder;
		this.familiesSize = familiesSize;
		this.condition = condition;
		this.ngrams = ngrams;
	}
	
	
	private void generateRule(String family, Config config, final DateTimeFormatter dtf, LocalDateTime now, List<Ngram> ngrams) {
		Controller controller = new Controller();
		if(ngrams.isEmpty()) {
			logger.info("Empty at: " + family + " - no folder created.");
			//emptyFamilies.add(family);
			return;
		}
		
		StringBuilder sb = new StringBuilder();
		for(WildcardConfig i : config.getWildcardConfigConfig()) {
			sb.append(i.wildcardOperator);
			sb.append(";");
		}
		sb.setLength(sb.length() - 1);
		
		String wildcardConfig = sb.toString();
				
		/*
		 * Step 6
		 * Create YARA-Signatures
		 */
		
		YaraRule yararule = controller.create();
		
		yararule.setImports(null);
		
		Rule rule = new Rule();
		rule.name = family.replace('.', '_');
		
		RuleMeta rulemeta = new RuleMeta();
		rulemeta.setAuthor("Felix Bilstein - yara-signator at cocacoding dot com");
		rulemeta.setDate(DateTimeFormatter.ofPattern("yyyy-MM-dd").format(now));
		rulemeta.setDescription("Describes " + family + ".");
		rulemeta.setInfo("autogenerated rule brought to you by yara-signator");
		
		rulemeta.setTool("yara-signator v" + Versioning.INSTANCE.VERSION);
		
		
		
		rulemeta.setToolConfig(wildcardConfig);
		rulemeta.setVersion("1");
		rulemeta.setMalpedia_ref("https://malpedia.caad.fkie.fraunhofer.de/details/" + rule.name.replace('.', '_').replaceFirst("_", "."));

		rulemeta.setMalpedia_rule_date(Versioning.INSTANCE.MALPEDIA_DATE);
		rulemeta.setMalpedia_version(Versioning.INSTANCE.MALPEDIA_DATE);
		rulemeta.setMalpedia_hash(Versioning.INSTANCE.MALPEDIA_COMMIT);

		
		rule.setComment(disclaimer);
		
		rulemeta.setMalpedia_license("CC BY-SA 4.0");
		rulemeta.setMalpedia_sharing("TLP:WHITE");
		rule.setMeta(rulemeta);
		
		RuleStrings rulestrings = new RuleStrings();
		int sequence_counter = 0;
		for(Ngram ngram : ngrams) {
			sb = new StringBuilder();
			sb.append("        $sequence_" + sequence_counter + " = { ");
			for(Instruction instr : ngram.getNgramInstructions()) {
				sb.append(instr.getOpcodes() + " ");
			}
			sb.append("}");
			if(config.scoreCommentEnabled) sb.append("\n            // n = " + ngram.n);
			if(config.scoreCommentEnabled) sb.append(", score = " + ngram.score);
			if(config.scoreCommentEnabled) {
				for(Instruction instr : ngram.getNgramInstructions()) {
					sb.append("\n            // ");
					if(instr.getMnemonics() != null && instr.getMnemonics().size() >= 2) {
						if(instr.getMnemonics().get(0).length() < 18 && instr.getAssemblySize()*2 < 18) {
							sb.append("  " + instr.getOpcodes() + (new String(new char[20-(instr.getAssemblySize()*2)]).replace('\0', ' ') ) +  " | " 
								+ instr.getMnemonics().get(0)  + (new String(new char[20-(instr.getMnemonics().get(0).length())]).replace('\0', ' ') ) + instr.getMnemonics().get(1));
						} else {
							sb.append("  " + instr.getOpcodes() + (new String(new char[4]).replace('\0', ' ') ) +  " | " 
								+ instr.getMnemonics().get(0)  + (new String(new char[4]).replace('\0', ' ') ) + instr.getMnemonics().get(1));
						}
					}
				}
				sb.append("\n");
			}
			rulestrings.addString(sb.toString());
			sequence_counter++;
		}
		rule.setStrings(rulestrings);
		
		RuleCondition rulecondition = new RuleCondition();
		rulecondition.setCondition("        " + condition);
		
		// DEBUGGING
		int c = (condition.length() - condition.replaceAll("filesize","").length())/("filesize".length());
		if( c > 1) {
			logger.error("FILESIZE is contained more than one time: "  + c);
		}
		
		rule.setCondition(rulecondition);
		
		yararule.setRule(rule);
		
		String output = "";
		if (  (this.output_folder != null) && (!this.output_folder.equalsIgnoreCase("")) ) {
			output = this.output_folder + "/" + family + "/yara/tlp_white/" + family + "_auto.yar";
		} else if( (config.resumeFolder != null) && (!config.resumeFolder.isEmpty()) && (!config.resumeFolder.equalsIgnoreCase("")) ) {
			output = config.output_path + "/" + config.resumeFolder + "/" + family + "/yara/tlp_white/" + family + "_auto.yar";
		} else {
			output = config.output_path + "/" + dtf.format(now) + "/" + family + "/yara/tlp_white/" + family + "_auto.yar";
		}
		File outputFile = new File(output);
		File parentFolder = outputFile.getParentFile();
		if (!parentFolder.exists() && !parentFolder.mkdirs()) {
		    throw new IllegalStateException("Unable to create folder: " + parentFolder);
		}
		try {
			FileWriter fw = new FileWriter(outputFile, false);
			fw.write(yararule.toString());
			fw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// Log the progress:
		outputFile = null;
		parentFolder = null;
		ngrams = null;
		String progress = "";
		if (  (this.output_folder != null) && (!this.output_folder.equalsIgnoreCase("")) ) {
			progress = this.output_folder + "/" + family + "/yara/tlp_white/" + family + "_auto.yar";
		} else if( (config.resumeFolder != null) && (!config.resumeFolder.isEmpty()) && (!config.resumeFolder.equalsIgnoreCase("")) ) {
			progress = config.output_path + "/" + config.resumeFolder + "/" + family + "/yara/tlp_white/" + family + "_auto.yar";
		} else {
			progress = config.output_path + "/" + dtf.format(now) + "/" + family + "/yara/tlp_white/" + family + "_auto.yar";
		}
		logger.info(counter + "/" + this.familiesSize + " Writing yara-rules to: " + progress);
	}
	
	@Override
	public void run() {
		if(this.ngrams == null) {
			try {
				NgramCreator nyq = new NgramCreator(config.capstone_host, config.capstone_port);
				ngrams = nyq.getNgramsForFamilyDefault(this.family_id, this.config);
				nyq.cleanDisasm();
			} catch (SQLException | DecoderException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		generateRule(this.family, this.config, this.dtf, this.now, this.ngrams);
	}

}
